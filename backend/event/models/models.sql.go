// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: models.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getControllableUnitCreateNotificationRecipients = `-- name: GetControllableUnitCreateNotificationRecipients :many
SELECT unnest(
    array_remove(
        array[ap.system_operator_id, apeu.end_user_id], null
    )
)::bigint
FROM controllable_unit AS cu
INNER JOIN accounting_point AS ap
ON cu.accounting_point_id = ap.id
LEFT JOIN accounting_point_end_user AS apeu
ON apeu.accounting_point_id = cu.accounting_point_id
WHERE cu.id = $1
AND apeu.valid_time_range @> current_timestamp
`

func (q *Queries) GetControllableUnitCreateNotificationRecipients(ctx context.Context, resourceID int) ([]int, error) {
	rows, err := q.db.Query(ctx, getControllableUnitCreateNotificationRecipients, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var column_1 int
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getControllableUnitLookupNotificationRecipients = `-- name: GetControllableUnitLookupNotificationRecipients :many
SELECT apeu.end_user_id::bigint
FROM controllable_unit AS cu
INNER JOIN accounting_point_end_user AS apeu ON apeu.accounting_point_id = cu.accounting_point_id
WHERE cu.id = $1
AND apeu.valid_time_range @> $2::timestamptz
`

func (q *Queries) GetControllableUnitLookupNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getControllableUnitLookupNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var apeu_end_user_id int
		if err := rows.Scan(&apeu_end_user_id); err != nil {
			return nil, err
		}
		items = append(items, apeu_end_user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getControllableUnitServiceProviderCreateNotificationRecipients = `-- name: GetControllableUnitServiceProviderCreateNotificationRecipients :many

SELECT unnest(
    array_remove(
        array[
            cusp.service_provider_id,
            ap.system_operator_id,
            apeu.end_user_id
        ],
        null
    )
)::bigint
FROM controllable_unit_service_provider AS cusp
INNER JOIN controllable_unit AS cu ON cu.id = cusp.controllable_unit_id
INNER JOIN accounting_point AS ap ON cu.accounting_point_id = ap.id
LEFT JOIN accounting_point_end_user AS apeu ON apeu.accounting_point_id = cu.accounting_point_id
WHERE cusp.id = $1
AND apeu.valid_time_range && tstzrange(cusp.valid_from, cusp.valid_to, '[)')
`

// using history on CU-SP because EU depends on valid time
//
//	the subquery allows us to get only the 2 latest versions of CU-SP at the
//	time of the event (i.e., both versions before and after the update)
//
// not using history on CU because AP ID is stable
// using the latest SO because AP.SO is not time-dependent
// just checking the start of the CU-SP valid time because functionally
//
//	speaking, this valid time should actually be aligned with the end user
//	valid time, so it is a way to avoid notifying people that are not really
//	concerned when we just correct a mistake
func (q *Queries) GetControllableUnitServiceProviderCreateNotificationRecipients(ctx context.Context, resourceID int) ([]int, error) {
	rows, err := q.db.Query(ctx, getControllableUnitServiceProviderCreateNotificationRecipients, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var column_1 int
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getControllableUnitServiceProviderUpdateDeleteNotificationRecipients = `-- name: GetControllableUnitServiceProviderUpdateDeleteNotificationRecipients :many
SELECT DISTINCT unnest(
    array_remove(
        array[
            cusph.service_provider_id,
            ap.system_operator_id,
            apeu.end_user_id
        ],
        null
    )
)::bigint
FROM (
    SELECT
        cusph.service_provider_id, cusph.controllable_unit_id,
        cusph.valid_from, cusph.valid_to
    FROM controllable_unit_service_provider_history AS cusph
    WHERE cusph.controllable_unit_service_provider_id = $1
    AND cusph.recorded_at <= $2
    ORDER BY cusph.recorded_at DESC LIMIT 2
) AS cusph
INNER JOIN controllable_unit AS cu ON cu.id = cusph.controllable_unit_id
INNER JOIN accounting_point AS ap ON cu.accounting_point_id = ap.id
LEFT JOIN accounting_point_end_user AS apeu ON apeu.accounting_point_id = cu.accounting_point_id
WHERE apeu.valid_time_range @> cusph.valid_from
`

func (q *Queries) GetControllableUnitServiceProviderUpdateDeleteNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getControllableUnitServiceProviderUpdateDeleteNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var column_1 int
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getControllableUnitUpdateNotificationRecipients = `-- name: GetControllableUnitUpdateNotificationRecipients :many

SELECT ap.system_operator_id
FROM controllable_unit AS cu
INNER JOIN accounting_point AS ap
ON cu.accounting_point_id = ap.id
WHERE cu.id = $1
AND cu.status != 'new'
UNION
SELECT service_provider_id
FROM controllable_unit_service_provider_history cusph
WHERE cusph.controllable_unit_id = $1
AND tstzrange(cusph.recorded_at, cusph.replaced_at, '[)') @> $2::timestamptz
AND cusph.valid_from IS NOT NULL
AND tstzrange(cusph.valid_from, cusph.valid_to, '[)') @> $2::timestamptz
`

// not using history on CU because AP ID is stable
// using the latest SO because AP.SO is not time-dependent
// not using history on APEU because we take the latest knowledge we have to
//
//	identify who to notify
//
// current timestamp because we take the relevant end user at the moment the
// event is processed
func (q *Queries) GetControllableUnitUpdateNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getControllableUnitUpdateNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var system_operator_id int
		if err := rows.Scan(&system_operator_id); err != nil {
			return nil, err
		}
		items = append(items, system_operator_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProviderProductApplicationCommentNotificationRecipients = `-- name: GetServiceProviderProductApplicationCommentNotificationRecipients :many
SELECT DISTINCT
    unnest(ARRAY[sppa.service_provider_id, sppa.system_operator_id])::bigint
FROM service_provider_product_application_comment_history AS sppach
    -- not using SPPA history because the resource cannot be deleted
    INNER JOIN service_provider_product_application AS sppa
        ON sppach.service_provider_product_application_id = sppa.id
WHERE sppach.service_provider_product_application_comment_id = $1
    AND tstzrange(sppach.recorded_at, sppach.replaced_at, '[]')
        @> $2::timestamptz
    -- private comments do not lead to notifications
    AND sppach.visibility = 'any_involved_party'
`

// using SPPA comment history because visibility can change over time
func (q *Queries) GetServiceProviderProductApplicationCommentNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProviderProductApplicationCommentNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var column_1 int
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProviderProductApplicationNotificationRecipients = `-- name: GetServiceProviderProductApplicationNotificationRecipients :many

SELECT unnest(array[system_operator_id, service_provider_id])::bigint
FROM service_provider_product_application_history
WHERE service_provider_product_application_id = $1
AND tstzrange(recorded_at, replaced_at, '[)') @> $2::timestamptz
`

// not using history on CU-SP for CU ID and SP ID because they are stable
// not using history on CU because AP ID is stable
// using the latest SO because AP.SO is not time-dependent
// not using history on APEU or CU-SP for end user ID because we take the
//
//	latest knowledge we have to identify who to notify and if it still
//	makes sense
//
// valid time check : notifying all end users that (up to the latest knowledge)
//
//	are in charge of the AP during at least a part of the CU-SP validity period
func (q *Queries) GetServiceProviderProductApplicationNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProviderProductApplicationNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var column_1 int
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProviderProductSuspensionCommentNotificationRecipients = `-- name: GetServiceProviderProductSuspensionCommentNotificationRecipients :many

SELECT DISTINCT
    unnest(
        ARRAY[sppsh.service_provider_id, sppsh.procuring_system_operator_id]
    )::bigint
FROM service_provider_product_suspension_comment_history AS sppsch
    -- using history because suspensions can be deleted
    INNER JOIN service_provider_product_suspension_history AS sppsh
        ON sppsch.service_provider_product_suspension_id
            = sppsh.service_provider_product_suspension_id
            AND tstzrange(sppsh.recorded_at, sppsh.replaced_at, '[]')
                @> $1::timestamptz
WHERE sppsch.service_provider_product_suspension_comment_id = $2
    AND tstzrange(sppsch.recorded_at, sppsch.replaced_at, '[]')
        @> $1::timestamptz
    -- private comments do not lead to notifications
    AND sppsch.visibility = 'any_involved_party'
`

// using inclusive end record time here because SPPS is a deletable resource
// (in order to notify delete events, we need to catch the last version in the
// history, which ends right at the event timestamp, so its record time does
// NOT contain it, so we do not catch it if we filter with exclusive end)
// using history because comments can be deleted
func (q *Queries) GetServiceProviderProductSuspensionCommentNotificationRecipients(ctx context.Context, recordedAt pgtype.Timestamptz, resourceID int) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProviderProductSuspensionCommentNotificationRecipients, recordedAt, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var column_1 int
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProviderProductSuspensionNotificationRecipients = `-- name: GetServiceProviderProductSuspensionNotificationRecipients :many
SELECT DISTINCT sppsh.service_provider_id::bigint
FROM service_provider_product_suspension_history AS sppsh
WHERE sppsh.service_provider_product_suspension_id = $1
    AND tstzrange(sppsh.recorded_at, sppsh.replaced_at, '[]') @> $2::timestamptz
UNION ALL
SELECT DISTINCT sppah.system_operator_id::bigint
FROM service_provider_product_suspension_history AS sppsh
    INNER JOIN service_provider_product_application_history AS sppah
        ON sppsh.service_provider_id = sppah.service_provider_id
            AND sppsh.product_type_ids && sppah.product_type_ids
            AND tstzrange(sppah.recorded_at, sppah.replaced_at, '[)')
                @> $2::timestamptz
WHERE sppsh.service_provider_product_suspension_id = $1
    AND tstzrange(sppsh.recorded_at, sppsh.replaced_at, '[]')
        @> $2::timestamptz
`

func (q *Queries) GetServiceProviderProductSuspensionNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProviderProductSuspensionNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var sppsh_service_provider_id int
		if err := rows.Scan(&sppsh_service_provider_id); err != nil {
			return nil, err
		}
		items = append(items, sppsh_service_provider_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupCreateNotificationRecipients = `-- name: GetServiceProvidingGroupCreateNotificationRecipients :many
SELECT service_provider_id
FROM service_providing_group spg
WHERE spg.id = $1
`

func (q *Queries) GetServiceProvidingGroupCreateNotificationRecipients(ctx context.Context, resourceID int) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupCreateNotificationRecipients, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var service_provider_id int
		if err := rows.Scan(&service_provider_id); err != nil {
			return nil, err
		}
		items = append(items, service_provider_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupGridPrequalificationNotificationRecipients = `-- name: GetServiceProvidingGroupGridPrequalificationNotificationRecipients :many
SELECT impacted_system_operator_id
FROM service_providing_group_grid_prequalification spggp
WHERE spggp.id = $1
UNION
SELECT service_provider_id
FROM service_providing_group spg
WHERE spg.id = (
    SELECT service_providing_group_id
    FROM service_providing_group_grid_prequalification spggp
    WHERE spggp.id = $1
)
`

func (q *Queries) GetServiceProvidingGroupGridPrequalificationNotificationRecipients(ctx context.Context, resourceID int) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupGridPrequalificationNotificationRecipients, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var impacted_system_operator_id int
		if err := rows.Scan(&impacted_system_operator_id); err != nil {
			return nil, err
		}
		items = append(items, impacted_system_operator_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupGridSuspensionCommentNotificationRecipients = `-- name: GetServiceProvidingGroupGridSuspensionCommentNotificationRecipients :many
SELECT DISTINCT
    unnest(ARRAY[
        spg.service_provider_id,
        spggsh.impacted_system_operator_id
    ])::bigint
FROM service_providing_group_grid_suspension_comment_history AS spggsch
    INNER JOIN service_providing_group_grid_suspension_history AS spggsh
        ON spggsch.service_providing_group_grid_suspension_id
            = spggsh.service_providing_group_grid_suspension_id
    -- SPG cannot be deleted + SP does not change
    INNER JOIN service_providing_group AS spg
        ON spggsh.service_providing_group_id = spg.id
WHERE spggsch.service_providing_group_grid_suspension_comment_id = $1
    AND tstzrange(spggsch.recorded_at, spggsch.replaced_at, '[]')
        @> $2::timestamptz
    AND tstzrange(spggsh.recorded_at, spggsh.replaced_at, '[]')
        @> $2::timestamptz
    -- private comments do not lead to notifications
    AND spggsch.visibility = 'any_involved_party'
`

// using SPGGS(C) history because of visibility + possible deletion
func (q *Queries) GetServiceProvidingGroupGridSuspensionCommentNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupGridSuspensionCommentNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var column_1 int
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupGridSuspensionNotificationRecipients = `-- name: GetServiceProvidingGroupGridSuspensionNotificationRecipients :many

SELECT spg.service_provider_id
FROM service_providing_group_grid_suspension_history AS spggsh
    INNER JOIN service_providing_group AS spg
        ON spggsh.service_providing_group_id = spg.id
    -- SPG cannot be deleted + SP does not change
WHERE spggsh.service_providing_group_grid_suspension_id = $1
    AND tstzrange(spggsh.recorded_at, spggsh.replaced_at, '[]')
        @> $2::timestamptz
UNION ALL
SELECT spggph.impacted_system_operator_id
FROM service_providing_group_grid_suspension_history AS spggsh
    INNER JOIN service_providing_group_grid_prequalification_history AS spggph
        ON spggsh.service_providing_group_id = spggph.service_providing_group_id
WHERE spggsh.service_providing_group_grid_suspension_id = $1
    AND tstzrange(spggsh.recorded_at, spggsh.replaced_at, '[]')
        @> $2::timestamptz
    AND tstzrange(spggph.recorded_at, spggph.replaced_at, '[]')
        @> $2::timestamptz
    AND notification.spg_grid_prequalification_ready_for_market_check(spggph)
UNION ALL
SELECT spgpah.procuring_system_operator_id
FROM service_providing_group_grid_suspension_history AS spggsh
    INNER JOIN service_providing_group_product_application_history AS spgpah
        ON spggsh.service_providing_group_id = spgpah.service_providing_group_id
WHERE spggsh.service_providing_group_grid_suspension_id = $1
    AND tstzrange(spggsh.recorded_at, spggsh.replaced_at, '[]')
        @> $2::timestamptz
    AND tstzrange(spgpah.recorded_at, spgpah.replaced_at, '[]')
        @> $2::timestamptz
    AND notification.spg_product_application_ready_for_market_check(spgpah)
`

// not using history on CU because AP ID is stable
// not using history on APEU because we take the latest knowledge we have to
//
//	identify who to notify
//
// SP
// ISO
// PSO
func (q *Queries) GetServiceProvidingGroupGridSuspensionNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupGridSuspensionNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var service_provider_id int
		if err := rows.Scan(&service_provider_id); err != nil {
			return nil, err
		}
		items = append(items, service_provider_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupMembershipNotificationRecipients = `-- name: GetServiceProvidingGroupMembershipNotificationRecipients :many
SELECT service_provider_id
FROM service_providing_group spg
WHERE spg.id = (
    SELECT distinct service_providing_group_id
    FROM service_providing_group_membership_history spgmh
    WHERE spgmh.service_providing_group_membership_id = $1
    AND tstzrange(spgmh.recorded_at, spgmh.replaced_at, '[]') @> $2::timestamptz
)
UNION
SELECT impacted_system_operator_id
FROM service_providing_group_grid_prequalification spggp
WHERE spggp.service_providing_group_id = (
    SELECT distinct service_providing_group_id
    FROM service_providing_group_membership_history spgmh
    WHERE spgmh.service_providing_group_membership_id = $1
    AND tstzrange(spgmh.recorded_at, spgmh.replaced_at, '[]') @> $2::timestamptz
)
`

func (q *Queries) GetServiceProvidingGroupMembershipNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupMembershipNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var service_provider_id int
		if err := rows.Scan(&service_provider_id); err != nil {
			return nil, err
		}
		items = append(items, service_provider_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupProductApplicationNotificationRecipients = `-- name: GetServiceProvidingGroupProductApplicationNotificationRecipients :many
SELECT spgpa.procuring_system_operator_id
FROM service_providing_group_product_application spgpa
WHERE spgpa.id = $1
UNION
SELECT spg.service_provider_id
FROM service_providing_group spg
WHERE spg.id = (
    SELECT service_providing_group_id
    FROM service_providing_group_product_application spgpa
    WHERE spgpa.id = $1
)
`

func (q *Queries) GetServiceProvidingGroupProductApplicationNotificationRecipients(ctx context.Context, resourceID int) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupProductApplicationNotificationRecipients, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var procuring_system_operator_id int
		if err := rows.Scan(&procuring_system_operator_id); err != nil {
			return nil, err
		}
		items = append(items, procuring_system_operator_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupProductSuspensionCommentNotificationRecipients = `-- name: GetServiceProvidingGroupProductSuspensionCommentNotificationRecipients :many
SELECT DISTINCT
    unnest(ARRAY[
        spg.service_provider_id,
        spgpsh.procuring_system_operator_id
    ])::bigint
FROM service_providing_group_product_suspension_comment_history AS spgpsch
    INNER JOIN service_providing_group_product_suspension_history AS spgpsh
        ON spgpsch.service_providing_group_product_suspension_id
            = spgpsh.service_providing_group_product_suspension_id
    -- SPG cannot be deleted + SP does not change
    INNER JOIN service_providing_group AS spg
        ON spgpsh.service_providing_group_id = spg.id
WHERE spgpsch.service_providing_group_product_suspension_comment_id = $1
    AND tstzrange(spgpsch.recorded_at, spgpsch.replaced_at, '[]')
        @> $2::timestamptz
    AND tstzrange(spgpsh.recorded_at, spgpsh.replaced_at, '[]')
        @> $2::timestamptz
    -- private comments do not lead to notifications
    AND spgpsch.visibility = 'any_involved_party'
`

// using SPGPS(C) history because of visibility + possible deletion
func (q *Queries) GetServiceProvidingGroupProductSuspensionCommentNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupProductSuspensionCommentNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var column_1 int
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupProductSuspensionNotificationRecipients = `-- name: GetServiceProvidingGroupProductSuspensionNotificationRecipients :many
SELECT spg.service_provider_id
FROM service_providing_group_product_suspension_history AS spgpsh
    INNER JOIN service_providing_group AS spg
        ON spgpsh.service_providing_group_id = spg.id
    -- SPG cannot be deleted + SP does not change
WHERE spgpsh.service_providing_group_product_suspension_id = $1
    AND tstzrange(spgpsh.recorded_at, spgpsh.replaced_at, '[]')
        @> $2::timestamptz
UNION ALL
SELECT spgpah.procuring_system_operator_id
FROM service_providing_group_product_suspension_history AS spgpsh
    INNER JOIN service_providing_group_product_application_history AS spgpah
        ON spgpsh.service_providing_group_id = spgpah.service_providing_group_id
WHERE spgpsh.service_providing_group_product_suspension_id = $1
    AND tstzrange(spgpsh.recorded_at, spgpsh.replaced_at, '[]')
        @> $2::timestamptz
    AND tstzrange(spgpah.recorded_at, spgpah.replaced_at, '[]')
        @> $2::timestamptz
    AND notification.spg_product_application_ready_for_market_check(spgpah)
`

// SP
// PSO
func (q *Queries) GetServiceProvidingGroupProductSuspensionNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupProductSuspensionNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var service_provider_id int
		if err := rows.Scan(&service_provider_id); err != nil {
			return nil, err
		}
		items = append(items, service_provider_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceProvidingGroupUpdateNotificationRecipients = `-- name: GetServiceProvidingGroupUpdateNotificationRecipients :many
SELECT service_provider_id
FROM service_providing_group spg
WHERE spg.id = $1
UNION
SELECT ap.system_operator_id
FROM controllable_unit AS cu
INNER JOIN accounting_point AS ap ON cu.accounting_point_id = ap.id
WHERE cu.id in (
    SELECT controllable_unit_id
    FROM service_providing_group_membership_history spgmh
    INNER JOIN service_providing_group_history spgh ON spgh.service_providing_group_id = spgmh.service_providing_group_id
    WHERE spgh.service_providing_group_id = $1
    AND spgh.status != 'new'
    AND tstzrange(spgh.recorded_at, spgh.replaced_at, '[)') @>  $2::timestamptz
    AND tstzrange(spgmh.recorded_at, spgmh.replaced_at, '[)') @>  $2::timestamptz
)
`

func (q *Queries) GetServiceProvidingGroupUpdateNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getServiceProvidingGroupUpdateNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var service_provider_id int
		if err := rows.Scan(&service_provider_id); err != nil {
			return nil, err
		}
		items = append(items, service_provider_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemOperatorProductTypeCreateNotificationRecipients = `-- name: GetSystemOperatorProductTypeCreateNotificationRecipients :many
SELECT system_operator_id
FROM system_operator_product_type sopt
WHERE sopt.id = $1
UNION
SELECT party_id FROM party_history
WHERE type = 'service_provider'
AND status = 'active'
AND tstzrange(recorded_at, replaced_at, '[)') @> $2::timestamptz
`

func (q *Queries) GetSystemOperatorProductTypeCreateNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getSystemOperatorProductTypeCreateNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var system_operator_id int
		if err := rows.Scan(&system_operator_id); err != nil {
			return nil, err
		}
		items = append(items, system_operator_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemOperatorProductTypeUpdateDeleteNotificationRecipients = `-- name: GetSystemOperatorProductTypeUpdateDeleteNotificationRecipients :many
SELECT system_operator_id
FROM system_operator_product_type sopt
WHERE sopt.id = $1
`

func (q *Queries) GetSystemOperatorProductTypeUpdateDeleteNotificationRecipients(ctx context.Context, resourceID int) ([]int, error) {
	rows, err := q.db.Query(ctx, getSystemOperatorProductTypeUpdateDeleteNotificationRecipients, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var system_operator_id int
		if err := rows.Scan(&system_operator_id); err != nil {
			return nil, err
		}
		items = append(items, system_operator_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTechnicalResourceNotificationRecipients = `-- name: GetTechnicalResourceNotificationRecipients :many
SELECT service_provider_id
FROM controllable_unit_service_provider_history cusph
WHERE cusph.controllable_unit_id = (
    SELECT controllable_unit_id
    FROM technical_resource_history trh
    WHERE trh.technical_resource_id = $1
    LIMIT 1
)
AND tstzrange(cusph.recorded_at, cusph.replaced_at, '[)') @> $2::timestamptz
AND cusph.valid_from IS NOT NULL
AND tstzrange(cusph.valid_from, cusph.valid_to, '[)') @> $2::timestamptz
UNION
SELECT ap.system_operator_id
FROM controllable_unit AS cu
INNER JOIN accounting_point AS ap ON cu.accounting_point_id = ap.id
WHERE cu.id = (
    SELECT controllable_unit_id
    FROM technical_resource_history trh
    WHERE trh.technical_resource_id = $1
    LIMIT 1
)
AND cu.status != 'new'
`

func (q *Queries) GetTechnicalResourceNotificationRecipients(ctx context.Context, resourceID int, recordedAt pgtype.Timestamptz) ([]int, error) {
	rows, err := q.db.Query(ctx, getTechnicalResourceNotificationRecipients, resourceID, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int
	for rows.Next() {
		var service_provider_id int
		if err := rows.Scan(&service_provider_id); err != nil {
			return nil, err
		}
		items = append(items, service_provider_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notify = `-- name: Notify :exec
INSERT INTO notification (event_id, party_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

func (q *Queries) Notify(ctx context.Context, eventID int, partyID int) error {
	_, err := q.db.Exec(ctx, notify, eventID, partyID)
	return err
}
