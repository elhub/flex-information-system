// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: models.sql

package models

import (
	"context"
)

const controllableUnitLookup = `-- name: ControllableUnitLookup :many
SELECT
    id::bigint,
    business_id::text,
    name::text,
    accounting_point_id::bigint,
    end_user_id::bigint,
    technical_resources::jsonb
FROM controllable_unit_lookup(
  $1,
  -- empty strings considered as missing values
  nullif($2::text, ''),
  nullif($3::text, '')
)
`

type ControllableUnitLookupRow struct {
	ID                 int
	BusinessID         string
	Name               string
	AccountingPointID  int
	EndUserID          int
	TechnicalResources []byte
}

func (q *Queries) ControllableUnitLookup(ctx context.Context, endUserBusinessID string, controllableUnitBusinessID string, accountingPointID string) ([]ControllableUnitLookupRow, error) {
	rows, err := q.db.Query(ctx, controllableUnitLookup, endUserBusinessID, controllableUnitBusinessID, accountingPointID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ControllableUnitLookupRow
	for rows.Next() {
		var i ControllableUnitLookupRow
		if err := rows.Scan(
			&i.ID,
			&i.BusinessID,
			&i.Name,
			&i.AccountingPointID,
			&i.EndUserID,
			&i.TechnicalResources,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
